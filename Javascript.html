<!DOCTYPE html>

<html lang="ko">

<head>

    <title>Javascript</title>

    <meta charset="UTF-8">
    <meta name="author" content="H-Genie">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <link rel="stylesheet" type="text/css" href="css/style.css">
    <link rel="icon" href="img/Javascript.png" sizes="16x16">
    
</head>

<body>

    <!--자바스크립트-->
    <div class="chapter_box" id="ch1-1" style="margin-top: 0;">

        <p class="subject">Javascript</p> <br>

        <p>
            자바스크립트 <br>
            &bull; 왜 생겼나? HTML로는 상호작용이 부족 <br>
            &bull; 특징 : 브라우저에 종속되어 있음 ⇒ 웹과 연동되어 작동 <br>
            &bull; node.js로 다른 환경으로 확장 가능
        </p> <br><br>

        <p>
            ECMA-262 기술규격에 정의된 표준화된 스크립트 프로그래밍 언어 <br>
            &bull; 스크립트 언어 : 응용 소프트웨어를 제어하는 프로그래밍 언어 / 응용 프로그램의 언어와 다른 언어로 사용되어, 응용 프로그램과 독립하여 사용되고 최종사용자가 응용 프로그램의 동작을 사용자의 요구에 맞게 수행할 수 있음 <br>
            &bull; ECMAScript라고도 함 <br>
            &bull; 2020년 4월 현재 ES2019가 최신버전이며, 가장 많이 사용하는 버전은 ES6
        </p> <br><br>

        <p>
            CRUD (프로그래밍의 기본 원리) <br>
            &bull;Create - 만들고 <br>
            &bull;Read - 읽고 <br>
            &bull;Update - 바꾸고 <br>
            &bull;Delete - 지우고

            <div class="content_box">
                <p>
                    &lt;프로그래밍 언어 ≒ 인간의 행동&gt; <br><br>
        
                    1. 정보를 기억 (Memory) <br>
                    - 인간 : 주변에 있는 사람을 기억 <br>
                    - 언어 : 변수를 선언 <br><br>
        
                    2. 조건을 판단 (Condition) <br>
                    - 인간 : 이 사람이 엄마이고, 이 사람이 아빠인지 판단 <br>
                    - 언어 : 조건문 (조건에 맞는 명령을 실행) <br><br>
        
                    3. 정보를 계산 (Operator) <br>
                    - 인간 : 백원짜리와 만원짜리가 같은지 계산 <br>
                    - 언어 : 산술을 연산 <br><br>
        
                    4. 행동 (Act) <br>
                    - 인간 : 아빠와 돈을 바꿈 <br>
                    - 언어 : 명령문 ⇒ 블럭으로 모이게 되면 함수 <br><br>
        
                    ※ 가족은 Object : "아빠는 누구고, 엄마는 누구고~"가 모여서 데이터가 됨
                </p>
            </div>
        </p> <br><br>

    </div>

    <!--자바스크립트 : 어휘 구조-->
    <div class="chapter_box" id="ch1-2">

        <p class="subject">어휘 구조 (Lexical Structure)</p> <br>

        <p>
            표현식(Expressions) : 값, 변수, 연산자의 조합 <br>
            키워드(예약어) : 예약된 명령문 (ex var은 변수라는 의미로 예약이 되어 있어서 식별자로 사용할 수 없음) <br>
            &bull;같은 의미에서, hyphen은 뺄셈을 위해 예약되어 있기때문에 식별자로 사용할 수 없음 <br><br>

            식별자 (Identifiers) : 변수(및 키워드, 함수 및 레이블)의 이름을 지정하는 데 사용 <br>
            &bull;첫번째 문자는 문자, 밑줄(_), 또는 달러 기호($)여야함 (JQuery에서 기본함수 $는 HTML 요소를 선택 : $("p"):모든 p요소 선택) <br>
            &bull;후속 문자는 문자, 숫자, 밑줄 또는 달러 기호 모두 가능 <br><br>

            JavaScript는 대소 문자를 구분함 <br>
            &bull;lastname ≠ lastName <br>
            &bull;주로 Lower Camel Case 사용 (ex firstName)
        </p> <br><br>

    </div>


    <!--데이터 : 타입-->
    <div class="chapter_box" id="ch2-1">

        <p class="subject">Data Type</p> <br>

        <p>
            &lt;Data Type&gt; : 변수에 저장할수 있는 자료 형 <br>
            ① 문자형(string) <br>
            ② 숫자형(number) <br>
            ③ 논리형(boolean) : 값이 있는 모든 것은 true / NaN, 0, 값이 없는 모든 것은 false<br>
            ④ 배열(Arrays) : 대괄호로 작성 / 배열 인덱스는 0부터 시작 / 숫자로 찾음 / 항목은 쉼표로 구성 <br>
            &bull;단, 배열의 데이터타입은 object <br>
            &nbsp;ex) var car=["Saab","Volvo","BMW"] <br>
            &nbsp;document.getElementById('demo').innerHTML=car[0] <br>
            ⑤ 빈 데이터(undefined) <br>
            ⑥ 빈 값(null) : 변수 비울 때 사용 / 유형은 object로 인식됨 <br>
            ⑦ 객체(Object) : 객체는 중괄호로 작성 / 이름으로 찾음 / 객체 속성은 쉼표로 구분 된 "이름 : 값" 쌍으로 작성 <br>
            &nbsp;ex) var person={firstName:"John", lastName:"Doe",age:50,eyeColor"blue"}; <br>   
            ⑧ 함수 : typeof function myFunc() {}
        </p> <br><br>

        <div class="content_box">
            <p>
                &lt;String Data Type Method&gt; <br>
                <a href="https://opentutorials.org/course/50/37" target="_blank">참고</a> <br><br>
                
                Escape Character <br>
                <table>
                    <tr><td>\"</td><td>큰 따옴표 삽입</td></tr>
                    <tr><td>\'</td><td>작은 따옴표 삽입</td></tr>
                    <tr><td>\\</td><td>백슬래쉬 삽입</td></tr>
                    <tr><td>\b</td><td>백스페이스 삽입</td></tr>
                    <tr><td>\f</td><td>프린터 출력시 다음페이지로 이동</td></tr>
                    <tr><td>\n</td><td>줄 바꿈</td></tr>
                    <tr><td>\r</td><td>행의 처음으로 이동</td></tr>
                    <tr><td>\t</td><td>가로 탭</td></tr>
                    <tr><td>\v</td><td>세로 탭</td></tr>
                </table> <br><br>

                &bull;문자열 찾기 <br>
                index of (찾을 문자열, 시작점) : 처음나오는 것을 찾음  / 강력한 검색값 (정규표현식)을 사용할 수 없음<br><br>
                lastIndexOf(찾을 문자열, 시작점) : 마지막 것을 찾아줌 <br><br>
                search() : 문자열에서 지정된 값을 검색하고 일치하는 값을 반환 / 찾는값이 없으면 -1 반환 <br><br><br>

                &bull;문자열 추출 <br>
                slice (start, end) : 문자열 일부를 추출하고 추출된 부분을 새 문자열로 반환 (시작점을 포함되고, 종료점은 포함되지 않음) <br>
                / 매개변수가 음수면 끝에서부터 계산함 (-12,-6) : 끝에서 12번자 숫자부터 뒤로 6글자 찾음 <br><br>
                substring(start, end) : slice와 비슷하지만 음수 색인을 사용할 수 없음 <br><br>
                substr (start, length) : 추출될 부분의 길이를 지정 / 첫번째 인수가 음수면 끝에서 부터 검색 <br><br><br>
                
                &bull;내용바꾸기 <br>
                replace(찾을값, 대체할값) : 대소문자 구분함 <br>
                (대소문자를 구분하지 않으려면 정규표현실 \i를 사용 & 기본값은 대소문자를 구분하는 \g) <br><br><br>

                &bull;대소문자 변환 <br>
                toUpperCase() / toLowerCase() <br><br><br>

                &bull;구분하기 <br>
                split("분리기호") : 나눠진 값은 ,로 구분함 / 문자열을 하위 문자열 배열로 분할하고 새 배열을 반환 (원래 문자열을 변경하지 않음)<br><br>
            </p>
        </div> <br>

        <div class="content_box">
            <p>
                &lt;Number Data Type Method&gt; <br><br>
                자바스크립트에서는 한가지 유형의 숫자만 있음 (다른 언어에는 정수형, 소수형등 여러가지 문자유형이 있음) <br><br>
                &bull;정수 : 최대 15자리 <br>
                &bull;소수 : 최대 17자리 (부동소수점 산술이 100% 정확하지는 않음) <br>
                &bull;Infinity : 최대자릿수를 벗어났을때의 값 (유형은 숫자) <br><br>

                &bull;NaN : 유효한 숫자가 아님을 증명하는 예약어 / Not a Number (※ NaN의 유형은 숫자) <br>
                &bull;isNaN() : "숫자가 아닌지"에 대한 여부를 알 수 있음 (값이 false여야 숫자) <br><br>

                &bull;16진수 → 10진수 : 0xFF = 255 <br><br><br>

                &bull;숫자 변환 <br><br>
                toString() : 문자를 숫자로 변환 (stirng type) <br><br>
                toExponential() : 수에 대한 지수표현식을 반환하는 (sting type) <a href="https://opentutorials.org/course/50/132" target="_blank">참고</a> <br><br>
                toFixed(소수자리수) : 소수점의 자리수 길이를 제한 / 생략하면 0=정수 (string type) <a href="https://opentutorials.org/course/50/133" target="_blank">참고</a> <br><br>
                toPrecision() : 수의 길이를 (반올림하여) 제한 (string type) <a href="https://opentutorials.org/course/50/134" target="_blank">참고</a> <br><br>

                Number() : 변수를 숫자로 반환 (앞뒤 공백은 무시해줌/중간공백은 안됨)
<pre>
    Number(true) : 1
    Number(false) : 0
    Number("10") : 10
    Number(" 10") : 10
    Number("10 ") : 10
    Number(" 10 ") : 10
    Number("10.33") : 10.33
    Number("10,33") : NaN
    Number("10 33") : NaN
    Number("John") : NaN
</pre> <br>

                parseInt() : 문자열을 구문 분석하고 정수를 반환 / 공백이 허용 / 첫번째 숫자만 반환 / 반올림은 안됨 (number type)  <a href="https://opentutorials.org/course/50/197" target="_blank">참고</a> <br><br>
<pre>
    parseInt("10") : 10
    parseInt("10.00") : 10
    parseInt("10.33") : 10
    parseInt("34 45 66") : 34
    parseInt(" 60 ") : 60
    parseInt("40 years") : 40
    parseInt("He was 40") : NaN

    parseInt("10",10) : 10
    parseInt("010") : 10
    parseInt("10",8) : 8
    parseInt("0xFF") : 255
    parseInt("10",16) : 16
</pre> <br>

                parseFloat() : 문자열을 구문 분석하고 실수를 반환 / 공백이 허용 / 첫번째 숫자만 반환  <a href="https://opentutorials.org/course/50/196" target="_blank">참고</a> <br><br>
<pre>    
    parseFloat("10") : 10
    parseFloat("10.00") : 10
    parseFloat("10.33") : 10.33
    parseFloat("34 45 66") : 34
    parseFloat(" 60 ") : 60
    parseFloat("40 years") : 40
    parseFloat("He was 40") : NaN
</pre> <br>               
            </p>
        </div>   
    </div>


    <!--데이터 : 변수-->
    <div class="chapter_box" id="ch2-2">

        <p class="subject">변수와 상수</p> <br>

        <p>
            고정값 : literal <br>
            → number, strings(문자열-따옴표 안에 써야함) <br>
            변수 : variable          
        </p> <br><br>
         
        <p>변수의 공간에는 하나의 데이터만 들어갈 수 있는 것은 아님 <br>
            ex) mySlide = document.getElementByClassname('mySlide')</p> <br>
        <p>왼쪽에서 오른쪽으로 식을 평가 : 순서가 다르면 결과가 다름 <br>
            &bull;var x = 16 +  "Volvo"; <br>
            &bull;var x = "Volvo" + 16 + 4;</p> <br>
        <p>재선언해도 해당 값이 손실되지 않음</p>
        <p>숫자를 따옴표로 묶으면 나머지 숫자는 문자열로 처리됨</p>
        <p>값없이 선언된 변수는 비어있는 것이 아니라 undefined라는 값이 있음</p> <br><br>
        
        <p>hoisting : 변수의 선언은 제일 상단으로 끌어 올림 (단, 선언 자체는 호이스팅 되지만, 값의 할당은 호이스팅 되지 않는다)</p> <br>

        템플릿 리터럴 : `${}` (태그, 함수, 변수 등등 자유롭게 들어갈 수 있음) <br><br>

        let, const : 블럭 스코프 (호이스팅 안됨) <br><br>

        같은 범위에서 var를 let으로 다시 선언하는 것은 허용되지 않음 <br><br>

        var : 블럭 스코프에서 빠져 나와서 다시 전역변수로 스코프 됨 / let : 블럭에서만 스코프 됨 <br>
        var : 윈도우 객체에 속함 (var = i, window.i) / let : 윈도우 객체에 속하지 않음 <br>

        const : let과 성질이 동일하나 재선언을 할 수 없음 (ex PI같은 것에 사용하면 좋음)<br>
        const : 상수의 성질이기 때문에 값이 없이 선언 할 수 없다 <br><br>
    </div>


    <!--연산자-->
    <div class="chapter_box" id="ch3">

        <p class="subject">연산자(Operator)</p> <br>

        <p>
            &lt;할당 연산자 (Assignment Operator) &gt; <br>
            <table>
                <tr style="background-color: #DEE1E6;"><td>Operator</td><td>Example</td><td>Same As</td></tr>
                <tr><td>=</td><td>x = y</td><td>x = y</td></tr>
                <tr><td>+=</td><td>x += y</td><td>x = x + y</td></tr>
                <tr><td>-=</td><td>x -= y</td><td>x = x - y</td></tr>
                <tr><td>*=</td><td>x *= y</td><td>x = x * y</td></tr>
                <tr><td>/=</td><td>x /= y</td><td>x = x / y</td></tr>
                <tr><td>%=</td><td>x %= y</td><td>x = x % y</td></tr>
                <tr><td>**=</td><td>x **= y</td><td>x = x ** y</td></tr>
            </table>
        </p> <br>

        <p>
            &lt;산술 연산자 (Arithmetic Operator) &gt; <br>
            <table>
                <tr style="background-color: #DEE1E6;"><td>Operator</td><td>Description</td><td></td></tr>
                <tr><td>+</td><td>Addition</td><td>더하기</td></tr>
                <tr><td>-</td><td>Subtraction</td><td>빼기</td></tr>
                <tr><td>*</td><td>Multiplication</td><td>곱하기</td></tr>
                <tr><td>**</td><td>Exponentiation</td><td>거듭제곱</td></tr>
                <tr><td>/</td><td>Division</td><td>나누기</td></tr>
                <tr><td>%</td><td>Modulus (Division Reminder)</td><td>나누기 후 나머지</td></tr>
                <tr><td>++</td><td>Increment</td><td>증가</td></tr>
                <tr><td>--</td><td>Decrement</td><td>감소</td></tr>
            </table>
        </p> <br>

        <p>
            &lt;비교 연산자 (Comparison Operator) &gt; <br>
            <table>
                <tr style="background-color: #DEE1E6;"><td>Operator</td><td>Description</td><td></td></tr>
                <tr><td>==</td><td>equal to</td><td>값이 같음</td></tr>
                <tr><td>===</td><td>equal value and equal type</td><td>값과 형식이 같음</td></tr>
                <tr><td>!=</td><td>not equal</td><td>같지 않음</td></tr>
                <tr><td>!==</td><td>not equal value or not equal type</td><td>값이 같지 않거나 형식이 같지 않음</td></tr>
                <tr><td>></td><td>greater than</td><td>크다</td></tr>
                <tr><td>&lt;</td><td>less than</td><td>작다</td></tr>
                <tr><td>>=</td><td>greater than equal to</td><td>크거나 같음</td></tr>
                <tr><td>&lt;=</td><td>less than or equal to</td><td>작거나 같음</td></tr>
                <tr><td>?</td><td>ternary operator</td><td>조건부 삼항 연산자 (조건에 따라 다른 값을 반환)</td></tr>
            </table>
        </p> <br>

        <p>
            &lt;조건부 연산자 (Ternary Operator) &gt; <br>
            일부 조건에 따라 변수에 값을 할당하는 조건부 연산자 <br><br>

            variablename = (condition) ? value1:value2 <br><br>

            var age = 29; <br>
            var canDrinkAlcohol = (age > 19)? "True, over 19" : "False, under 19"; <br>
            console.log(canDrinkAlcohol);
        </p> <br><br>

        <p>
            &lt;논리 연산자 (Logical Operator) &gt; <br>
            <table>
                <tr style="background-color: #DEE1E6;"><td>Operator</td><td>Description</td><td>Example</td></tr>
                <tr><td>&&</td><td>and</td><td>(x<10 && y>1</10>)</td></tr>
                <tr><td>||</td><td>or</td><td>(x==5 || y==5)</td></tr>
                <tr><td>!</td><td>not</td><td>!(x==y)</td></tr>               
            </table>
        </p> <br>

        <p>
            &lt;유형 연산자&gt; <br>
            &bull;typeof OOO (연산자 변수 또는 표현식의 타입을 반환) <br>
            &bull;instance OOO (클래스에 속하거나 상속여부에 따라 boolean으로 변환)
        </p>
    </div>


    <!--문징 : 조건문-->
    <div class="chapter_box" id="ch4-1">

        <p class="subject">조건문 (Conditional Statement)</p> <br>

        if, else if, else, swith (모든 글자를 소문자로 써야 함) <br><br>

        <p>
            &bull;Switch문 : 많은 대체 코드 블록 중에 원하는 조건에 맞는 코드 블럭을 실행 <br><br>

            switch (expression) { <br>
                case0: break; <br>
                case1: break; <br>
                caseX: break; <br>
                default: <br>
            } <br><br>

            1. 여러 사례가 사례값과 일치하면 첫번째 사례가 선택됨 <br>
            2. 일치하는 사례가 없으면 프로그램은 기본 레이블(default)로 계속 진행 <br>
            3. 기본 레이블이 없으면 프로그램은 전환 후에 명령문으로 계속 진행 <br>
            4. 스위치 케이스는 엄격한 비교(===, Strict Comparison)를 사용. 값이 일치하려면 동일한 유형이어야 함
        </p>

    </div>
    

    <!--문장 : 루프-->
    <div class="chapter_box" id="ch4-2">

        <p class="subject">Loop</p> <br>

        <p>
            &lt;반복문> <br>
            : 매번 다른 값으로 동일한 코드를 반복해서 실행 (특히, 배열로 작업시) <br><br>
            
            &bull;for : 코드 블럭을 여러 번 반복 <br>
            &bull;for in : 객체의 속성을 반복 <br>
            &bull;for of : 반복 가능한 객체의 값을 반복 <br>
            &bull;while : 지정된 조건이 참인 동안 코드블럭을 반복 <br>
            &bull;do while : 지정된 조건이 참인 동안 코드블럭을 반복 (do를 먼저 실행하고 반복문을 실행)
        </p> <br><br>

       
        <div class="content_box">
            <p>
                &lt;For Loop> <br>
                for (statement1; statement2; statement3) <br><br>

                명령문1은 코드블럭을 실행하기 전에 한번 실행 <br>
                명령문2는 코드블럭을 실행하기 위한 조건을 정의 <br>
                코드블럭이 실행된 후 (매번) 명령문3이 실행됨
            </p>
        </div> <br><br>

        <p>
            &lt;명령문1> <br>
            일반적으로 명령문1을 사용하여 루프에 사용된 변수를 초기화 함 (i=0;) <br>
            명령문 1은 선택사항 <br>
            명령문1에서 많은 값을 시작할 수 있음 (쉼표로 구분) <br><br>

<pre>
&lt;p id="demo">&lt;/p> <br>
&lt;script>
var cars=["BMW","Volvo","Saab","Ford"];
var i, len, txt;
for (i=0, len=cars.length, text=""; i&lt;len; i++) {
    txt+=cars[i]+"&lt;br>";
}
document.getElementById("demo").innerHTML=txt;
&lt;/script>
</pre> <br>
            
            루프1이 시작되기 전에 값이 설정될 때와 같이 명령문1을 생략할 수 있음 <br><br>

<pre>
&lt;p id="demo">&lt;/p> <br>
&lt;script>
var cars=["BMW","Volvo","Saab","Ford"];
var i=2;
var len=cars.length;
var txt="";
for (; i<&lt;len; i++) {
    txt+=cars[i]+"&lt;br>";
}
document.getElementById("demo").innerHTML=txt;
&lt;/script>
</pre> <br>
        </p> <br><br>

        <p>
            &lt;명령문2> <br>
            명령문2는 종종 초기 변수의 조건을 평가하는 데 사용 <br>
            명령문 2도 선택사항 <br>
            명령문2가 true를 리턴하면 루프가 다시 시작되고, false를 리턴하면 루프가 종료됨 <br>
            명령문2를 생략하면 루프 내부에 중단을 제공해야 함 <br>
            그렇지 않으면 루프가 끝내지 않고 브라우저가 다운됨 (무한루프) <br><br>
        </p> <br><br>

        <p>
            &lt;명령문3> <br>
            명령문3은 종종 초기 변수의 값을 증가시킴 <br>
            명령문3은 음수 증분(i--), 양수 증분(i=i+15) 또는 기타 다른 작업을 수행 할 수 있음 <br>
            루프 내에서 값을 증가시킬 떄와 같이 명령문3도 생략할 수 있음 <br><br>

<pre>
&lt;p id="demo">&lt;/p> <br>
&lt;script>
var cars=["BMW","Volvo","Saab","Ford"];
var i=0;
var len=cars.length;
var txt="";
for (; i<&lt;len;) {
    txt+=cars[i]+"&lt;br>";
}
document.getElementById("demo").innerHTML=txt;
&lt;/script>
</pre>
        </p> <br><br>

        <div class="content_box">
            <p>
                &lt;For/In Loop> <br><br>
                for/in문은 객체의 속성을 반복함 <br>
                배열도 객체이기 때문에 배열에서도 사용 가능
            </p>
        </div> <br>
        <P>
<pre>
&lt;p id="demo">&lt;/p> <br>
&lt;script>
var txt=""
var person={fname:"John",lname:"Doe",age:25};
var x;
for (x in person) {
    txt += person[x] + " ";
}
document.getElementById("demo").innerHTML=txt;
&lt;/script>
</pre>
        </P> <br><br>

        <div class="content_box">
            <p>
                &lt;For/Of Loop> <br><br>
                for/of문은 반복가능한 객체의 값을 반복함 <br>
                배열, 문자열, 맵, 노드, 목록 등고 같이 반복 가능한 데이터 구조를 반복할 수 있음 <br><br>

                for (variable of iterable) { <br><br>
                
                <span style="font-size: smaller;">
                * variable : 반복할 때마다 다음 특성의 값이 변수에 지정됨 <br>
                * iterable : 반복 가능한 속성을 가진 객체
                </span> <br><br>
                배열, 문자(한글자씩) 다 가능
            </p>
        </div> <br>


        <div class="content_box">
            <p>
                &lt;While Loop> <br><br>
                지정된 조건이 true면 루프는 코드블럭을 실행할 수 있음 <br>
                조건에 사용된 변수를 늘리는 것을 잊어 버리면 루프가 끝나지 않고 브라우저가 다운됨 <br><br>

                while (condition) { <br><br>
                    
                증감이 조건 안에 있게 됨
            </p>
        </div> <br>
        <p>
<pre>
&lt;p id="demo">&lt;/p> <br>
&lt;script>
var txt=""
var i=0;
while (i&lt;10) {
    txt += "&lt;br> The number is"+ i; i++;
}
document.getElementById("demo").innerHTML=txt;
&lt;/script>
</pre>
        </p> <br><br>


        <div class="content_box">
            <p>
                &lt;Do / While Loop> <br><br>
                while 루프의 변종 <br>
                이 루프는 조건이 참인지 확인하기 전에 코드블럭을 한번 실행 한 다음 조건이 참이면 루프를 반복 <br><br>

                do { } <br>
                while (condition);
            </p>
        </div> <br>
        <p>
<pre>
&lt;p id="demo">&lt;/p> <br>
&lt;script>
var txt=""
var i=0;
do {txt += "&lt;br> The number is" + i; i++;}
while (i&lt;10);
document.getElementById("demo").innerHTML=txt;
&lt;/script>
</pre>
        </p> <br><br>

    </div>


    <!--함수 : 함수-->
    <div class="chapter_box" id="ch5-1">

        <p class="subject">함수 (Function)</p> <br>

        <div class="content_box">
            <p>
                &lt;프로그래밍 언어의 발전> <br><br>

                ① Anlaog (ex 주판) : Memory가 안됨 <br>
                → <span style="color: blue;">variable(저장)</span> <br>
                &nbsp;&nbsp;&nbsp;&nbsp; + <span style="color: blue;"> Operator(할당,연산)</span> <br>
                → <span style="color: blue;">Condition (조건)</span> <br>
                &nbsp;&nbsp;&nbsp;&nbsp; + <span style="color: blue;"> Loop (반복)</span> <br><br>

                ② <strong>function</strong> (Processor) = 코드블럭 : 똑같은 계산을 반복하게 됨 <br>
                * but, 함수가 너무 많아지게 됨 (ex 망치+톱+드라이버 : 편할것 같지만 무거워서 아무도 안씀) <br>
                → 기능별로 나눠서 쓰면 편함 (ex 전동 드라이버) <br><br>

                ③ <strong>Object</strong> : 함수의 기능을 쪼갬 (=공구함) <br>
                (ex 가계부 : 수입만 계산 / 지출만 계산) ⇒ 합쳐서 쓰면 재사용하기 힘듦 <br><br>

                &bull;object는 property와 method로 구성되어 있음 = property(=literal) / method(=function) <br>
                &bull;A method is function stored as a property <br><br>

                &bull;공구 혹은 공구함을 배포 : Library = API <br>
                &bull;작업실을 배포 : Framework <br><br>

                * OOP : Object Oriented Program 객체지향 프로그램 (C → C++ (object C))
            </p>
        </div> <br><br>

        <div class="content_box">
            <p>
                &lt;이벤트를 만드는 과정>  <br><br>
               변수 <br>
               ↓ <br>
               조건문/반복문 + 연산자 <br>
               ↓ <br>
               함수 (=재사용 가능한 코드블럭) <br>
               ↓ <br>
               event (☞ call) (이벤트가 필요하면 eventlistener)
            </p>
        </div> <br><br>

        <p>
            함수 : <br>
            ① 특정 작업을 수행하도록 설계된 코드 블럭 <br>
            ② 다른(or자기자신) 어떤 것이 호출될 때 실행 <br><br>

            매개변수 = parameter
        </p> <br><br>

        <p>
            Syntax(구문) <br>
            &bull;function 키워드, 이름, 괄호, 중괄호로 정의됨 <br>
            &bull;함수 이름에는 문자, 숫자, 밑줄, 달러 기호가 포함될 수 있음 (변수와 규칙이 같음) <br>
            &bull;괄호에는 쉼표로 구분 된 parameter가 포함될 수 있음 <br>
            &bull;함수가 실행할 코드는 중괄호{} 안에 있음 <br><br>

            &bull;함수 매개변수는 함수 정의에서 괄호() 안에 표시 됨 <br>
            &bull;함수 인수는 함수가 호출 될 때 함수가 받는 값 <br>
            &bull;함수 내에서 인수(매개변수)는 로컬변수로 동작함 <br><br>

            &bull;()연산자는 함수를 호출함 : ()없이 함수에 액세스하면 함수 결과 대신 함수 객체가 반환됨 <br>
        </p> <br><br>

        <p>
            함수 호출 : <br><br>
            함수 내부의 코드는 어떤 것이 함수를 호출할 때 실행 <br>
            1) 이벤트 발생시(사용자가 버튼을 클릭할 때) <br>
            2) JavaScript 코드에서 호출될 떄 <br>
            3) 자동(자체호출)
        </p> <br><br>

        <p>
            함수 변환 : <br><br>
            JavaScript가 return 명령문에 도달하면 함수 실행이 중지됨 <br>
            &nbsp;(cf switch, loop : break / 함수 : return (중단과 동시에 반환)) <br>
            함수가 명령문에서 호출된 경우, JavaScript는 호출 명령문 이후에 코드를 실행하기 위해 "반환"함 <br>
            함수는 종종 반환값을 계산함. 반환값은 "호출자"에게 반환됨 <br><br>

<pre>
&lt;p id="demo">&lt;/p> <br>
&lt;script>
var x=myFunction(4,3);
document.getElementById("demo").innerHTML=x;
Function myFunction(a,b) {
    return a*b;
}
&lt;/script>
</pre>
            
        </p> <br><br>

        <p>
            왜 함수를 사용하는가? <br><br>
            1) 코드를 재사용 할 수 있음 <br>
            2) 코드를 한번 정의하고 여러번 사용 <br>
            3) 다른 인수로 동일한 코드를 여러번 사용하여 다른 결과를 생성할 수 있음
        </p> <br><br>

        <p>
            지역 변수 : <br><br>
            함수 내에 선언된 변수는 함수의 LOCAL이 됨 <br>
            지역 변수는 함수 내에서만 액세스 할 수 있음 <br>
            지역 변수는 함수 안에서만 인식되므로 같은 이름의 변수를 다른 함수에서 사용할 수 있음 <br>
            지역 변수는 함수가 시작될 때 생성되고 함수가 완료되면 삭제됨
        </p> <br><br>

        <div class="content_box">
            <p>
                &lt;함수 표현식>  <br><br>
               
                함수 표현식이 변수에 저장된 후에는 변수를 함수로 사용할 수 있음 <br><br>

<pre>
&lt;p id="demo">&lt;/p>
&lt;script>
var x = function (a,b) {return a * b};
document.getElementById("demo").onnerHTML = x(4,3);
&lt;/script>
</pre>
            </p>
        </div>

        <div class="content_box">
            <p>
                &lt;함수 매개변수와 인수>  <br><br>
               
                함수에는 arguments라는 내장객체가 있음. <br>
                arguments 객체는 함수가 호출될 때 사용된 인수 배열을 포함 <br><br>

<pre>
&lt;p id="demo">&lt;/p>
&lt;script>
function findMax() {
    var i;
    var max = - Infinity;
    for (i=0; i &lt; arguments.lenght; i++) {
        if (arguments[i] > max) {
            max = arguments[i]; }
    } return max;
}
document.getElementById("demo").innerHTML = findMax(4,5,6);
&lt;/script>
</pre>
            </p>
        </div>

    </div>


    <!--함수 : 수학-->
    <div class="chapter_box" id="ch5-2">

        <p class="subject">Math 함수</p> <br>

        <table>
            <tr><td>메서드</td><td>개요</td><td>이용 예</td></tr>
            <tr><td>abs</td><td>절대값</td><td>Math.abs(-10)</td></tr>
            <tr><td>pow</td><td>거듭제곱</td><td>Math.pow(2,3)</td></tr>
            <tr><td>PI</td><td>원주율</td><td>Math.PI</td></tr>
            <tr><td>round</td><td>반올림</td><td>Math.round(4.7)</td></tr>
        </table> <br><br>

        <p>
            &lt; Random 함수 > <br><br>
            Math.random() : 0(포함)과 1(제외) 사이의 난수를 반환함 <br><br>
<pre>
&lt;p id="demo">&lt;/p> <br>
&lt;script>
document.getElementBiId('demo').innerHTML = Math.random();
&lt;/script>
</pre> <br><br>

            Math.random()과 함께 Math.floor()/Math.ceil()를 사용하면 임의의 정수를 반환할 수 있음 <br><br>
<pre>
&lt;p id="demo">&lt;/p> <br>
&lt;script>
document.getElementBiId('demo').innerHTML = Math.floor(Math.random()*10);
&lt;/script>
</pre> <br><br>
                
            <table>
                <tr><td>Math.floor(Math.random()*10);</td><td>0 ~ 9</td></tr>
                <tr><td>Math.floor(Math.random()*11);</td><td>0 ~ 10</td></tr>
                <tr><td>Math.floor(Math.random()*100);</td><td>0 ~ 99</td></tr>
                <tr><td>Math.floor(Math.random()*100)+1;</td><td>1 ~ 100</td></tr>
                <tr><td>Math.floor(Math.random()*101);</td><td>0 ~ 100</td></tr>
            </table> <br><br>
            응용 : 50~99를 하고 싶으면, *50 + 50 <br><br>

            최대값과 최소값을 지정하면 그 사이의 난수 발생 <br>
            &bull;최소값은 포함, 최대값은 제외 <br>
            function getRandom(min,max) { <br>
                return Math.floor(Math.random()*(max-min))+min;} <br>
            &bull;최소값과 최대값을 모두 포함할 경우 <br>
            function getRandom(min,max) { <br>
                return Math.floor(Math.random()*(max-min+1))+min;} <br>
            
        </p> <br><br>

    </div>


    <!--객체-->
    <div class="chapter_box" id="ch6">

        <p class="subject">객체 (Object)</p> <br>

        <div class="content_box">
            <p>
                자동차를 하나의 객체로 예를 들어보면, <br>
                자동차에는 무게와 색상과 같은 속성과 <br>
                시작 및 중지와 같은 방법이 있음. <br><br>
                <table>
                    <tr style="text-align: center;"><td>객체<br>Object</td><td>속성<br>Properties</td><td>방법<br>Methods</td></tr>
                    <tr><td>자동차</td><td>car.name=피아트<br>car.model=500<br>car.weight=850Kg<br>car.color=white</td><td>car.start( )<br>car.drive( )<br>car.break( )<br>car.stop( )</td></tr>
                </table> <br>

                모든 자동차의 속성은 동일하지만 속성값은 자동차마다 다름 <br>
                모든 자동차는 동일한 방법을 사용하지만 방법은 다른 시간에 수행됨 <br>
                (속성의 이름은 같고, 값을 저마다 다름)
            </p>
        </div> <br><br>

        <p>
            객체도 변수임. 그러나 객체에는 많은 값이 포함될 수 있음. <br>
            var car={type:"Fiat", model:"500", color:"white"}; <br>
            &bull;car.type="Fiat" <br>
            &bull;car.model="500" <br><br>

            값은 name:value 쌍 (이름과 값을 콜론으로 구분)으로 작성 <br>
            자바스크립트 객체는 속성 또는 메서드로 명명된 값의 컨테이너 <br><br>

            객체방법 : 속성과 메서드를 가질 수 있음 <br>
            메서드는 오브젝트에서 수행할 수 있는 조치 <br>
            메서드는 함수정의로 특성에 저장 <br><br>

            메써드 : 객체의 프로퍼티에 함수를 할당해 객체에게 행동할수 있는 능력을 부여 / 객체에 프로퍼터에 할당된 함수를 메서드라 한다
        </p> <br><br>

        <p>
            style="display: ;" - 오브젝트라 짝이 맞아야 함 <br>
            style.display=" "
        </p> <br><br>

        <p>
            cf) <br>
            배열 : id를 지정하면 동작이 많아질수록 불편함 <br>
            - 숫자로 표현 : 1학년 1반의 - 1번은 누구~ 2번은 누구~ / 이름표를 안붙이고 번호표만 붙여서 창고에 집어넣음(순서가 중요) <br>
            오브젝트 : something=something / 다양하게 지정 가능(숫자, 문자 등) / 이름표를 붙여서 창고에 집어넣음
        </p> <br><br>

    </div>


    <!--배열-->
    <div class="chapter_box" id="ch7">

        <p class="subject">배열 (Array)</p> <br>
        
        <p>
            단일 변수에 여러값을 저장하는데 사용(대괄호) : 0부터 시작 <br>
            &bull;둘 이상의 값을 보유할 수 있는 특수 변수 <br>
            &bull;색인번호를 참조(=CRUD)하여 값에 엑세스 할 수 있음 <br>
            &bull;배열안에 변수를 넣을 수도 있음 <br><br>

            대괄호로 작성 / 쉼표로 구분 (≠Collection) <br>
            isArray()로 배열인지 여부를 알 수 있음 <br>
            배열의 type은 object <br><br>

            특정요소만 변경할 수 있음 (ex cars[1]="Benz") <br>
            &bull; 배열 : 숫자를 사용하여 요소에 엑세스 / 객체 : 이름을 사용하여 "멤버"에 엑세스 (값 부분에 함수가 들어가 메서드가 될 수 있음) <br><br>

            배열은 특별한 유형의 객체임 (객체 ⊃ 배열) <br>
            &bull; 배열에 함수를 넣어볼까? ☞ 객체 (객체가 나중에 생겼지만 거꾸로 됨) <br><br>

            배열의 값으로 객체, 함수, 배열을 가질 수 있음 (※객체에 배열이 포함되어 있기 때문에) <br><br>

            배열에도 내장 메써드를 적용할 수 있음 (cars.length) <br><br>

            <div class="content_box">
                <p>
                    &lt;배열 메서드> : 배열이름.메서드() <a href="https://www.w3schools.com/jsref/jsref_obj_array.asp" target="_blank">참고</a> <br><br>

                    push("oo") : 배열에 새 요소 추가 <br>
                    &nbsp;ex) cars.push("OO") = cars[cars.length] => 구멍이 날 수 있음 <br><br>

                    toString() : 배열을 쉼표로 구분된 문자열로 반환해줌 <br>
                    &nbsp;cf) join("구분자") : 구분자를 선택지정할 수 있음 <br><br>

                    pop() : 배열의 마지막 요소를 제거해줌 (↔ push) <br>
                    &nbsp;cf) 변수로 선언하면 삭제되는 값을 리턴함 (원래 배열에는 해당 값이 삭제됨) <br>
                    &nbsp;delete를 사용하면 구멍이 날 수 있으므로(cars[cars.length]와 마찬가로), pop이나 shift를 사용하는 것이 좋음 <br><br>                    

                    shift() : 첫번째 배열요소를 제거하고 다른 모든 요소를 더 낮은 인덱스로 이동시킴 <br>
                    &nbsp;cf) 변수로 선언하면 pop과 마찬가지로 제거된 값(=첫번째값)이 보여짐 <br><br>

                    unshift() : 새 요소를 추가하고 이전요소를 "변동해제"함 (=인덱스 하나씩 늘어남) <br>
                    &nbsp;cf) 변수로 사용되면 새로운 배열길이를 사용함 <br><br>

                    splice(위치, 제거해야 하는 요소 수, "추가할 새 요소") : 배열에 새 항목을 추가 <br>
                    &nbsp;&bull; 두번째 인수를 0으로 하면 지우지 않고 추가 <br>
                    &nbsp;&bull; 세번째 인수를 생략하면 구멍을 남기지 않고 요소를 제거할 수 있음 <br>
                    &nbsp;cf) 변수로 선언하면 삭제된 값이 반환됨 <br><br>

                    concat() : 기본 배열을 병합하여 새 배열을 만듦 <br>
                    &nbsp;ex) var myChildren = myGirls.concat(myBoys); <br><br>

                    slice(시작위치, 종료위치) : 배열의 일부를 새로운 배열로 잘라냄 (시작점은 포함되고, 종료점은 포함안됨)<br><br>

                    sort() : 오름차순 (배열을 변화시킴)  / 문자열로 정렬됨 (숫자를 정렬할때는 비교기능을 사용해야 함)<br>
                   &nbsp;cf) 배열이름.sort(function(a,b) {return a-b;}); <br>
                   &nbsp;sort()원리 : 두개의 요소를 가져와서 크기를 비교 / a-b가 양수면 앞뒤 바꿔줌, 0이거나 음수면 그대로 둠<br><br>

                   &nbsp;cf) 숫자 내림차순 : 배열이름.sort(function(a,b) {return a-b;}) 후 reverse <br>
                   &nbsp;reverse의 원리 : 배열이름.sort(function(a,b) {return b-a;}); <br><br>

                   reverse() : 배열의 Index를 뒤집어줌 (sort를 먼저 해주고 난 후에 해야 내림차순의 효과가 남) <br><br>

                   - 랜덤정렬 : <br>
                   &nbsp;배열이름.sort(function(a,b){return 기준숫자 - Math.random()}) <br>
                   &nbsp;기준 숫자가 : 양수에 가까울 수록 오름차순에 가깝고, 음수에 가까울수록 랜덤해짐 <br><br>

                   - 최대, 최소값 찾기 : <br>
                   &nbsp;배열이름.sort(function(a,b) {return a-b;}) <br>
                   &nbsp;배열이름[0] cf)최대값 : 배열이름[length-1] <br>
                   &nbsp;cf) 단순히 최대값을 찾는거면 Math.max.apply(null,배열이름)를 사용하는 것이 좋음 <br><br>

                   forEach(function(currentValue, index, arr), thisValue) : 각 배열요소에 대해 콜백함수를 한 번 호출 <br>
                   &nbsp;cf) index, arr / thisValue는 생략가능 <br><br>
                   
                   map(function(currentValue, index, arr), thisValue) : 각 배열 요소에 대해 기능을 수행하여 새 배열을 작성 / 값이없는 배열 요소에 대한 함수를 실행하지 않음 / 원래 배열을 변경하지 않음 <br>
                   &nbsp;cf) index, arr / thisValue는 생략가능 <br><br>

                   filter(function(currentValue, index, arr), thisValue) : 조건을 만족하는 배열 요소를 새 배열로 만듦 <br>
                   &nbsp;cf) index, arr / thisValue는 생략가능 <br><br>

                   reduce(function(total, currentValue, currentIndex, arr), initialValue) : 단일값을 생성(감소) (ex:합계,평균 등) 하기 위해 각 배열요소에서 함수를 실행 / 왼쪽에서 오른쪽으로 작동 / 원래배열을 변경하지 않음 <br>
                   &nbsp;cf) currentIndex, arr / initialValue는 생략가능 <br>
                   &nbsp;cf) 초기값을 적용할 수 있음 배열이름.reduce(함수,초기값) <br>
                   &nbsp;cf) reduceRight(function(total, currentValue, currentIndex, arr), initialValue) : reduce와 같으나 오른쪽에서 왼쪽으로 작동 <br><br>

                    every(function(currentValue, index, arr), thisValue) : "모든" 배열값이 조건을 만족했는지 확인 / 원래 배열은 변경하지 않음 / Boolean을 반환<br>
                    &nbsp;cf) index, arr / thisValue는 생략가능 <br>
                    &nbsp;cf) some(function(currentValue, index, arr), thisValue) : 일부 배열 값이 조건을 만족했는지 확인 <br><br>

                    indexOf(item,start) : 배열에서 요소 값을 검색하고 해당 위치(몇번째 멤버인가)를 반환 / 첫번째 발생위치를 반환 / 찾을 수 없으면 -1을 반환 <br>
                    &nbsp;cf) 두번째 인수는 생략가능 <br>
                    &nbsp;cf) lastIndexOf(item,start) : (중복된 값이 있을 때) 마지막 요소를 찾아줌 <br><br>

                    find(function(currentValue, index, arr),thisValue) : 조건을 만족하는 첫번째 배열 요소의 값을 반환 <br>
                    &nbsp;cf) index, arr / thisValue는 생략가능 <br>
                    &nbsp;cf) findIndex() : 조건을 만족하는 배열 요소의 색인을 반환 <br>
                </p>
            </div> <br>
            
        </p>

    </div>

     
     <!--이벤트-->
     <div class="chapter_box" id="ch8">

        <p class="subject">Event</p> <br>

        <p>
            하나의 요소에 많은 이벤트 핸들러를 추가할 수 있음 <br>
            하나의 요소(ex 두 개의 클릭이벤트)에 동일한 유형의 많은 이벤트 핸들러를 추가 할 수 있음 <br><br>

            HTML 요소뿐만 아니라 모든 DOM 객체에 이벤트 리스너를 추가할 수 있음 (윈도우 객체) <br><br>

            addEventListener() 방법을 사용하면 이벤트가 버블링에 반응하는 방식을 보다 쉽게 제어할 수 있음 <br>
            addEventListener() 메소드를 사용할 때 JavaScript는 HTML 마크업과 분리되어 가독성을 높이고 HTML을 제어하지 않더라도 이벤트 리스너를 추가할 수 있음 <br>
            removeEventListner() 메소드를 사용하여 이벤트 리스너를 쉽게 제거할 수 있음 <br><br>

            Syntax : <br>
            element.addEventListener("event",function,useCapture) <br>
            &bull;이벤트에 "on" 접두사를 사용하지 말 것 ☞ "onclick" 대신 "click" 사용 <br><br>

            전달 매개 변수 (passung parameters) : 매개 변수 값을 전달할 때 매개변수와 함께 지정된 함수를 호출하는 "익명함수"를 사용 <br>

<pre>
&lt;button id="myBtn">Try it&lt;/p>
&lt;p id="demo">&lt;/p> <br>
&lt;script>
var p1=5; var p2=7;
document.getElementBiId('myBtn').addEventListener("click",<strong>function(){</strong>myFunction(p1,p2)})
function myFunction(a,b) {
    var result=a*b;
    document.getElementById('demo').innerHTML=result;}
&lt;/script>
</pre> <br><br>       

            이벤트 전파 (버블링/캡쳐) <br>
            이벤트 전파는 이벤트가 발생할 때 요소 순서를 정의하는 방법 <br>
            &bull;버블링(기본값/false 혹은 생략) : 내부 요소의 이벤트가 먼저 처리되고, 다음 외부 요소의 이벤트가 처리 됨 <br>
            &bull;캡처링(true) : 가장 외부 요소의 이벤트가 먼저 처리되고, 다음으로 내부 요소의 이벤트가 처리 됨 <br><br>

            addEventListener() 메소드를 사용하면 "useCapture" 매개 변수를 사용하여 전파 유형을 지정할 수 있음 <br><br>
            addEventListener("event",function,useCapture) : <br>
            기본값은 false이고 이는 버블링 전파를 사용하며, 값이 true로 설정되면 이벤트는 캡처 전파를 사용함

        </p> <br><br>

    </div>


    <!--문서 스크립팅 : DOM-->
    <div class="chapter_box" id="ch9-1">

        <p class="subject">HTML DOM</p> <br>

        <p>
            HTML DOM : 언어 중립적 / 모든 요소는 object로 정의됨 <br><br>
            <a href="https://www.w3schools.com/jsref/dom_obj_style.asp" target="_blank">DOM Style</a>
        </p> <br><br>

        <p>    
            &lt; 문서 요소 선택 > <br><br>
            &bull;ID 속성을 지정해서 선택하기 <br>
            &bull;name 속성을 지정해서 선택하기 <br>
            &bull;HTML 태그 이름을 지정해서 선택하기 <br>
            &bull;CSS class이름(들)을 지정해서 선택하기 <br>
            &bull;지정한 CSS 선택자와 일치 여부로 선택하기 <br><br>
            
            &bull;querySelectorAll() : 지정된 CSS 선택기와 일치하는 모든 HTML 요소(ID, 클래스 네임, 유형 속성, 속성값 등)를 찾음 <br><br>

<pre>
&lt;p class="intro">The DOM is very useful.&lt;/p>
&lt;p class="intro">This example demonstrates the querySelectorAll method.&lt;/p>
&lt;p id="demo">&lt;/p> <br>
&lt;script>
var x = document.querySelectorAll('p.intro');
document.getElementById('demo').innerHTML = 
x[0].innerHTML;
&lt;/script> 
</pre>
        </p> <br><br>
    
    </div>


    <!--문서 스크립팅 : 구조 탐색-->
    <div class="chapter_box" id="ch9-2">

        <p class="subject">HTML DOM Navigation</p> <br>

        <p>
            &bull; DOM NAvigation : 다음 노드 속성을 사용하요 노드 사이를 탐색할 수 있음 <br>
            → parentNode / childNodes[Collection] / firstChild / lastChild / nextSibling / previousSibling / nodeName / nodeValue / nodeType <br><br>
            <span style="font-size: small;">* DOM처리에서 흔히 발생하는 오류는 요소 노드에 텍스트가 포함될 것으로 예상하는 것</span>
        </p> <br><br>

        <div class="content_box">
            <p>
                &lt; 문서가 Node 트리일 때 > <br><br>
                &bull;parentNode : 한 객체의 부모에 해당하는 상위 Node 객체. Document 객체처럼 부모 객체가 없으면 null <br>
                cf) children[collection] : Element <br>
                cf) childNodes[collection] : Node <br><br>
                &bull;childNode : 읽기 전용 유사 배열 객체인 NodeList이며, 한 노드의 자식 노드에 대한 실시간 변화를 반영 <br><br>
                &bull;firstChild, lastChild : 한 노드의 자식 노드 중 첫번째 노드와 마지막 노드, 자식 노드가 없다면 null <br><br>
                &bull;nextSibling, previousSibling : 한 노드의 이전 혹은 다음의 형제 노드. 같은 부모 노드를 가진 두 노드를 형제 노드라고 한다. 형제 노드 간의 순서는 문서에 나타난 순서대로이다. 이 속성은 노드를 사슬처럼 양쪽으로 연결
            </p>
        </div>

        <div class="content_box">
            <p>
                &lt; 문서가 Element 트리일 때 > <br><br>                
                &bull;firstElementChild, lastElementChild : firstChild, lastChild 프로퍼티와 유사하지만 Element 자속 객체만 반환함 <br><br>
                &bull;nextElementSibling, previousElementSibling : nextSibling, previousSibling 프로퍼티와 유사하지만 Element 형제 객체만 반환함 <br><br>
                &bull;childElementCount : 자손 객체의 수. childrne.length와 같은 값을 반환함
            </p>
        </div> <br>

        <p>
            &bull; nodeName Property <br>
            nodeName은 읽기전용 <br>
            nodeName은 HTML 요소의 대문자 태그 이름을 포함함 <br><br>
            <table>
                <tr><td>요소 노드</td><td>태그 이름</td></tr>
                <tr><td>속성 노드</td><td>속성 이름</td></tr>
                <tr><td>텍스트 노드</td><td>#text</td></tr>
                <tr><td>문서 노드</td><td>#document</td></tr>
            </table> <br>

<pre>
&lt;h1 id="id01">My First Page.&lt;/h1>
&lt;p id="id02">&lt;/p>
&lt;script>
document.getElementById('id02').innerHTML = document.getElementById('id02').nodeName;
&lt;/script> 
</pre>
        </p> <br><br>

        <p>
            &bull; nodeValue Property <br>
            nodeValue 속성은 노드의 값을 지정함 <br>       
            cf) innerHTML 메서드 : 요소의 textNode value에 접근함 <br>
            cf) document.getElementById('demo').innerHTML = document.getElementById('demo').childNodes[0].nodeValue <br><br>
            <table>
                <tr><td>요소 노드</td><td>null</td></tr>
                <tr><td>텍스트 노드</td><td>텍스트 자체</td></tr>
                <tr><td>속성 노드</td><td>속성값</td></tr>                
            </table> <br>

<pre>
&lt;h1 id="id01">My First Page.&lt;/h1>
&lt;p id="id02">&lt;/p>
&lt;script>
document.getElementById('id02').innerHTML = document.getElementById('id02').nodeValue;
&lt;/script> 
</pre>
        </p> <br><br>

        <p>
            &bull; nodeType Property <br>            
            <table>
                <tr><td>Node</td><td>type</td><td>Example</td></tr>
                <tr><td>element Node</td><td>1</td><td>&lt;p id="demo">Hello World!&lt;/p></td></tr>
                <tr><td>attribute Node</td><td>2</td><td>class="heading"</td></tr>
                <tr><td>text Node</td><td>3</td><td>Hello World!</td></tr>
                <tr><td>comment Node</td><td>8</td><td>&lt;!--comment--></td></tr>
                <tr><td>document Node</td><td>9</td><td>HTML document itself</td></tr>
                <tr><td>document_type Node</td><td>10</td><td>&lt;!Doctype html></td></tr>
            </table> <br>
        </p> <br><br>

    </div>


     <!--문서 스크립팅 : 노드의 생성-->
     <div class="chapter_box" id="ch9-3">

        <p class="subject">노드의 생성,삽입,삭제</p> <br>

        <p>
            &bull;Creating New HTML Element <br>
            : HTML DOM에 새 요소를 추가하려면 먼저 요소(요소 노드)를 작성한 다음 기존 요소에 추가합니다. <br><br>

<pre>
&lt;div id="div1">
&lt;p id="p1">This is paragraph.&lt;/p>
&lt;p id="p2">This is another paragraph.&lt;/p>
&lt;/div>

&lt;script>
var para = document.createElement("p");
var node = document.createTextNode("this is new");
para.appendChild(node);
var element = document.getElementById("div1");
element.appendChild(para);
&lt;/script> 
</pre> <br><br>

            <div class="content_box">
                <p>
                   1) 새로운 p요소를 만듦 <br>
                   var para = document.createElement("p"); <br><br>

                   2) p 요소에 텍스트를 추가하려면 먼저 텍스트 노드를 작성 <br>
                   var node = document.createTextNode("this is new"); <br><br>

                   3) 텍스트 노드를 p요소에 추가함 <br>
                   para.appendChild(node); <br><br>

                   4) 추가할 부모 요소를 찾아 새 요소를 추가함 <br>
                   var element = document.getElementById("div1"); <br><br>

                   5) 새 요소를 기존 요소에 추가함 <br>
                   element.appendChild(para); <br>
                   <span style="font-size: small; color: blue;">cf) element.insertBefore(newnode,existingnode)</span> <br><br>
                   cf) appendChild : after와 비슷 / insertBefore : before와 비슷 (매개변수가 있어서 위치지정이 가능함)
                </p>
            </div> <br><br>
        </p>

        <p>
            &bull;Removing Existing HTML Element <br>
            : HTML 요소를 제거하려면 remove() 메서드를 사용. <br><br>

<pre>
&lt;div id="div1">
&lt;p id="p1">This is paragraph.&lt;/p>
&lt;p id="p2">This is another paragraph.&lt;/p>
&lt;/div>
&lt;button onclick="myFunction()">Remove Element&lt;/button>

&lt;script>
function myFunction() {
    var elmnt = document.getElementById("p1");
    elmnt.remove();
}
&lt;/script> 
</pre> <br><br>
          
        </p>

        <p>
            &bull;Replacing HTML Element <br>
            : 요소를 HTML DOM으로 바꾸려면 replaceChild() 메서드를 사용. <br><br>

<pre>
&lt;div id="div1">
&lt;p id="p1">This is paragraph.&lt;/p>
&lt;p id="p2">This is another paragraph.&lt;/p>
&lt;/div>

&lt;script>
var para = document.createElement("p");
var node = document.createTextNode("this is new");
para.appendChild(node);
var parent = document.getElementById("div1");
var child = document.getElementById("p1");
parent.replaceChild(para,child);
&lt;/script> 
</pre> <br><br>
          
        </p>
    
    </div>



     <!--정규표현식-->
     <div class="chapter_box" id="ch10">

        <p class="subject">정규표현식</p> <br>

        <p>
            정규식은 검색 패턴을 형성하는 일련의 문자. <br>
            구문 : /pattern/modifiers; <br><br>

            정규식은 단일 문자이거나 더 복잡한 패턴 일 수 있음 <br><br>
            
            정규식을 사용하여 모든 유형의 텍스트 검색 및 텍스트 바꾸기 작업을 수행할 수 있음 <br><br>

            자바스크립트에서 정규표현식은 보통 search()와 replace() 메소드와 함께 사용함 <br>
            &bull; search() 메소드는 표현식을 사용하여 일치하는 항목을 검색하고 일치하는 위치를 반환 <br>
            &bull; replace() 메소드는 패턴으로 교체 또는 수정 된 문자열을 리턴
        </p> <br>

        <div class="content_box">
            <p>
                수정자 (Modifiers)
                <table>
                    <tr><td>Modifiers</td><td>Description</td></tr>
                    <tr><td>/ /i</td><td>대소문자를 구별하지 않는 매칭을 수행</td></tr>
                    <tr><td>/ /g</td><td>전역 매칭을 수행. 처음 매치에서 끝내지 않고 모든 매치를 찾음</td></tr>
                    <tr><td>/ /m</td><td>여러 줄 모드. ^은 줄의 시작이나 문자열의 시작과 일치하고, $는 줄의 끝이나 문자열의 끝과 일치</td></tr>
                </table>
            </p>
        </div> <br>

        <div class="content_box">
            <p>
                대괄호 (Bracket)
                <table>
                    <tr><td>Modifiers</td><td>Description</td></tr>
                    <tr><td>[abc]</td><td>Find any of the character between the bracket</td></tr>
                    <tr><td>[0-9]</td><td>Find any of the digits between the bracket</td></tr>
                    <tr><td>(x|y)</td><td>Find any of the alternatives separated with |</td></tr>
                </table>
            </p>
        </div> <br>

        <div class="content_box">
            <p>
                Meta Character
                <table>
                    <tr><td>Modifiers</td><td>Description</td></tr>
                    <tr><td>\d</td><td>Find a digit</td></tr>
                    <tr><td>\s</td><td>Find a whitespace character</td></tr>
                    <tr><td>\b</td><td>Find a match at the beginning of a word like this: \bWORD. or at the end of a word like this: WORD\b</td></tr>
                    <tr><td>\uxxxx</td><td>Find the Unicode character specified by the hexadecmal</td></tr>
                </table>
            </p>
        </div> <br>

    </div>



    <!--그래픽 : CANVAS-->
    <div class="chapter_box" id="ch11-1">

        <p class="subject">CANVAS</p> <br>

        <div class="content_box">
            <p>
                <a href="https://www.w3schools.com/tags/ref_canvas.asp" target="_blank">W3School : HTML CANVAS</a> <br><br>
        
                <a href="https://www.w3schools.com/tags/canvas_stroke.asp" target="_blank">stroke()</a> <br>
                <a href="https://www.w3schools.com/tags/canvas_strokestyle.asp" target="_blank">strokeStyle</a> <br><br>

                <a href="https://www.w3schools.com/tags/canvas_font.asp" target="_blank">font</a>                
            </p>
        </div> <br>


        <canvas id="canvas_stroke" width="300" height="300" style="border: 1px solid black;"></canvas>
        <script>
            document.getElementById('canvas_stroke').getContext("2d").beginPath();
            document.getElementById('canvas_stroke').getContext("2d").moveTo(20,20);
            document.getElementById('canvas_stroke').getContext("2d").lineTo(20,150);
            document.getElementById('canvas_stroke').getContext("2d").lineTo(150,150);
            document.getElementById('canvas_stroke').getContext("2d").lineWidth = 5;
            document.getElementById('canvas_stroke').getContext("2d").strokeStyle = "blue";
            document.getElementById('canvas_stroke').getContext("2d").stroke();
        </script>
<pre>
document.getElementById('canvas_stroke').getContext("2d").beginPath(); //경로를 시작하거나, 초기화 하는 메써드
document.getElementById('canvas_stroke').getContext("2d").moveTo(0,0); //시작점으로 좌표를 이동시키는 메써드 (x축,y축)
document.getElementById('canvas_stroke').getContext("2d").lineTo(20,150); //시작점(혹은 이전의 경로가 끝나는점)에서부터 다음 좌표로 경로를 그림 (x축,y축)
document.getElementById('canvas_stroke').getContext("2d").lineTo(150,150);
document.getElementById('canvas_stroke').getContext("2d").lineWidth = 5; //라인의 굵기를 지정
document.getElementById('canvas_stroke').getContext("2d").strokeStyle = "blue"; //stroke의 스타일을 지정 (색 or 그라디언트 or 패턴)
document.getElementById('canvas_stroke').getContext("2d").stroke(); // moveTo, lineTo의 경로를 모두 그림
</pre> <br><br>


    <canvas id="canvas_circle" width="300" height="300" style="border: 1px solid black;"></canvas> <br>
    <p>angle</p>
    <img src="https://www.w3schools.com/tags/img_arc.gif">
    <script>
        document.getElementById('canvas_circle').getContext("2d").beginPath();
        document.getElementById('canvas_circle').getContext("2d").arc(150,150,50,0,Math.PI);
        document.getElementById('canvas_circle').getContext("2d").lineWidth = 10;
        document.getElementById('canvas_circle').getContext("2d").strokeStyle = "red";
        document.getElementById('canvas_circle').getContext("2d").lineCap = "round"
        document.getElementById('canvas_circle').getContext("2d").stroke();

        document.getElementById('canvas_circle').getContext("2d").beginPath();
        document.getElementById('canvas_circle').getContext("2d").arc(75,75,25,Math.PI,0);
        document.getElementById('canvas_circle').getContext("2d").lineWidth = 5;
        document.getElementById('canvas_circle').getContext("2d").strokeStyle = "red";
        document.getElementById('canvas_circle').getContext("2d").lineCap = "round"
        document.getElementById('canvas_circle').getContext("2d").stroke();

        document.getElementById('canvas_circle').getContext("2d").beginPath();
        document.getElementById('canvas_circle').getContext("2d").arc(225,75,25,Math.PI,0);
        document.getElementById('canvas_circle').getContext("2d").lineWidth = 5;
        document.getElementById('canvas_circle').getContext("2d").strokeStyle = "red";
        document.getElementById('canvas_circle').getContext("2d").lineCap = "round"
        document.getElementById('canvas_circle').getContext("2d").stroke();
    </script>
<pre>
document.getElementById('canvas_circle').getContext("2d").beginPath();
document.getElementById('canvas_circle').getContext("2d").arc(150,150,50,0,Math.PI); // (원중심의 x좌표, 원중심의 y좌표, 반지름, 시작각도:0이면 3시방향, 종료각도)
document.getElementById('canvas_circle').getContext("2d").lineWidth = 5;
document.getElementById('canvas_circle').getContext("2d").strokeStyle = "red";
document.getElementById('canvas_circle').getContext("2d").lineCap = "round" //모서리 끝의 모양을 지정 (butt or round or square)
document.getElementById('canvas_circle').getContext("2d").stroke();
</pre> <br><br>


    <canvas id="canvas_rectangle" width="300" height="300" style="border: 1px solid black;"></canvas>
    <script>        
        document.getElementById('canvas_rectangle').getContext("2d").fillStyle = "yellow";
        document.getElementById('canvas_rectangle').getContext("2d").fillRect(50,50,100,100);
    </script>
<pre>
document.getElementById('canvas_rectangle').getContext("2d").fillStyle = "yellow"; //fill의 스타일을 지정 (색 or 그라디언트 or 패턴)
document.getElementById('canvas_rectangle').getContext("2d").fillRect(50,50,100,100); // (좌측상단의 x좌표, 좌측상단의 y좌표, 넓이, 높이)
</pre> <br><br>


    <canvas id="canvas_text" width="300" height="300" style="border: 1px solid black;"></canvas>
    <script>
        document.getElementById('canvas_text').getContext("2d").font = "italic small-caps 100 50px fantasy"; // 크기, 폰트이름
        document.getElementById('canvas_text').getContext("2d").fillText("fillText",25,100); // Fill Text : 문구, X좌표, Y좌표
        document.getElementById('canvas_text').getContext("2d").font = "normal normal 900 50px fantasy";
        document.getElementById('canvas_text').getContext("2d").strokeText("strokeText",25,200); // Outline Text : 문구, X좌표, Y좌표
    </script>
<pre>
document.getElementById('canvas_text').getContext("2d").font = "italic small-caps 100 50px fantasy"; // font-style / font-variant / font-weight / font-size / font-family
document.getElementById('canvas_text').getContext("2d").fillText("fillText",25,100); // Fill Text(문구, 좌측상단의 X좌표, 좌측상단의 Y좌표)
document.getElementById('canvas_text').getContext("2d").font = "normal normal 900 50px fantasy";
document.getElementById('canvas_text').getContext("2d").strokeText("strokeText",25,200); // Outline Text(문구, 좌측상단의 X좌표, 좌측상단의 Y좌표)
</pre> <br><br>


    <canvas id="canvas_gradient" width="300" height="300" style="border: 1px solid black;"></canvas>  
    <script>        
        var gradient = document.getElementById("canvas_gradient").getContext("2d").createLinearGradient(0, 0, 170, 0);        
        gradient.addColorStop(0, "black");
        gradient.addColorStop(1, "white");
        document.getElementById("canvas_gradient").getContext("2d").fillStyle = gradient;
        document.getElementById("canvas_gradient").getContext("2d").fillRect(20, 20, 150, 100);        
    </script>
<pre>
var gradient = document.getElementById("canvas_gradient").getContext("2d").createLinearGradient(0, 0, 170, 0); // 그라디언트 메써드는 object 함수로 정의되므로, 반드시 변수로 지정해줘야 함
gradient.addColorStop(0, "black"); // addColorStop(value(0~1), color)
gradient.addColorStop(1, "white");
document.getElementById("canvas_gradient").getContext("2d").fillStyle = gradient;
document.getElementById("canvas_gradient").getContext("2d").fillRect(20, 20, 150, 100);
</pre> <br><br>

    <img src="https://www.w3schools.com/tags/img_the_scream.jpg" id="original_img"> <br><br>
    <canvas id="canvas_image" width="300" height="300" style="border: 1px solid black;"></canvas>
    <script>        
        window.onload = function() {
            document.getElementById("canvas_image").getContext("2d").drawImage(document.getElementById("original_img"), 10, 10);
        }        
    </script>
<pre>
window.onload = function() { //클라이언트에서는 함수로 실행해야 함
    document.getElementById("canvas_image").getContext("2d").drawImage(document.getElementById("original_img"), 10, 10); 
    //drawImage(미디어의 Element, 좌측상단의 x좌표, 좌측상단의 y좌표)
}
</pre> <br><br>

    <p>&lt;Canvas Animation></p>
    <canvas id="canvas_ani" width="500" height="500" style="border: 1px solid black;"></canvas>
    <script>
        var xx = 250;
        var yy = 250;
        var dx = Math.ceil ( Math.random() * 10 );
        var dy = Math.ceil ( Math.random() * 10 );

        function draw() {
            document.getElementById("canvas_ani").getContext("2d").clearRect(0,0,500,500); //좌표 사이의 캔버스 요소를 지움
            document.getElementById('canvas_ani').getContext("2d").beginPath();
            document.getElementById('canvas_ani').getContext("2d").arc(xx,yy,20,0,Math.PI * 2);
            document.getElementById('canvas_ani').getContext("2d").lineWidth = 10;
            document.getElementById('canvas_ani').getContext("2d").fillStyle = "red";            
            document.getElementById('canvas_ani').getContext("2d").stroke();
        }
              
       function aniStart() {                   
           xx += dx;
           yy += dy;
           var tt = setTimeout(aniStart,20);

           if(xx > 480) {dx = -dx;} else if (xx <20) {dx = -dx;}
           if(yy > 480) {dy = -dy;} else if (yy <20) {dy = -dy;}
           draw();                        
        }       
       aniStart();        
    </script>
<pre>
var xx = 250;
var yy = 250;
var dx = Math.ceil ( Math.random() * 10 );
var dy = Math.ceil ( Math.random() * 10 );

function draw() {
    document.getElementById("canvas_gradient").getContext("2d").clearRect(0,0,500,500); //좌표 사이의 캔버스 요소를 지움
    document.getElementById('canvas_gradient').getContext("2d").beginPath();
    document.getElementById('canvas_gradient').getContext("2d").arc(xx,yy,20,0,Math.PI * 2);
    document.getElementById('canvas_gradient').getContext("2d").lineWidth = 10;
    document.getElementById('canvas_gradient').getContext("2d").fillStyle = "red";            
    document.getElementById('canvas_gradient').getContext("2d").stroke();
}

// 반대편으로 튕기기
function aniStart() {                   
    xx += dx;
    yy += dy;
    var tt = setTimeout(aniStart,20);

    if(xx > 480) {dx = -dx;} else if (xx &lt; 20) {dx = -dx;}
    if(yy > 480) {dy = -dy;} else if (yy &lt; 20) {dy = -dy;}
    draw();                        
}

// y축 충돌감지
function aniStart() {        
    xx += dx;
    yy += dy;
    var tt = setTimeout(aniStart,10);
                
    if(yy > 480) {clearTimeout(tt)}
    draw();
}

aniStart();        
</pre>

    </div>



     <!--그래픽 : SVG-->
     <div class="chapter_box" id="ch11-2">

        <p class="subject">Scarable Vector Graphic</p> <br>

        <svg height="210" width="500">
            <line x1="0" y1="0" x2="200" y2="200" style="stroke:rgb(255,0,0);stroke-width:2" />
        </svg>
        <p>
            &lt;svg height="210" width="500"> <br>
            &nbsp;&nbsp;&lt;line x1="0" y1="0" x2="200" y2="200" style="stroke:rgb(255,0,0);stroke-width:2" /> <br>
            &lt;/svg> 
        </p> <br>


        <svg height="180" width="500">
            <polyline points="0,40 40,40 40,80 80,80 80,120 120,120 120,160" style="fill:white;stroke:red;stroke-width:4" />
        </svg>
        <p>
            &lt;svg height="180" width="500"> <br>
            &nbsp;&nbsp;&lt;polyline points="0,40 40,40 40,80 80,80 80,120 120,120 120,160" style="fill:white;stroke:red;stroke-width:4" /> <br>
            &lt;/svg>
        </p> <br>


        <svg height="100" width="100">
            <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" />
        </svg>
        <p>
            &lt;svg height="100" width="100"> <br>
            &nbsp;&nbsp;&lt;circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" /> <br>
            &lt;/svg>
        </p> <br>


        <svg width="400" height="110">
            <rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
        </svg>
        <p>
            &lt;svg width="400" height="110"> <br>
            &nbsp;&nbsp;&lt;rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" /> <br>
            &lt;/svg>
        </p> <br>


        <svg width="400" height="180">
            <rect x="50" y="20" rx="20" ry="20" width="150" height="150" style="fill:red;stroke:black;stroke-width:5;opacity:0.5" />
        </svg>
        <p>
            &lt;svg width="400" height="180"> <br>
            &nbsp;&nbsp;&lt;rect x="50" y="20" rx="20" ry="20" width="150" height="150" style="fill:red;stroke:black;stroke-width:5;opacity:0.5" /> <br>
            &lt;/svg>
        </p> <br>


        <svg height="250" width="500">
            <polygon points="220,10 300,210 170,250 123,234" style="fill:lime;stroke:purple;stroke-width:1" />
        </svg>
        <p>
            &lt;svg height="250" width="500"> <br>
            &nbsp;&nbsp;&lt;polygon points="220,10 300,210 170,250 123,234" style="fill:lime;stroke:purple;stroke-width:1" /> <br>
            &lt;/svg>
        </p> <br>


        <svg height="210" width="500">
            <polygon points="100,10 40,198 190,78 10,78 160,198" style="fill:lime;stroke:purple;stroke-width:5;fill-rule:nonzero;" />
        </svg>
        <p>
            &lt;svg height="210" width="500"> <br>
            &nbsp;&nbsp;&lt;polygon points="100,10 40,198 190,78 10,78 160,198" style="fill:lime;stroke:purple;stroke-width:5;fill-rule:<span style="color: blue;">nonzero</span>;" /> <br>
            &lt;/svg>
        </p> <br>


        <svg height="210" width="500">
            <polygon points="100,10 40,198 190,78 10,78 160,198" style="fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;" />
        </svg>
        <p>
            &lt;svg height="210" width="500"> <br>
            &nbsp;&nbsp;&lt;polygon points="100,10 40,198 190,78 10,78 160,198" style="fill:lime;stroke:purple;stroke-width:5;fill-rule:<span style="color: blue;">evenodd</span>;" /> <br>
            &lt;/svg>
        </p> <br>


        <svg height="150" width="400">
            <defs>
              <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" style="stop-color:rgb(255,255,0);stop-opacity:1" />
                <stop offset="100%" style="stop-color:rgb(255,0,0);stop-opacity:1" />
              </linearGradient>
            </defs>
            <ellipse cx="200" cy="70" rx="85" ry="55" fill="url(#grad1)" />
            <text fill="#ffffff" font-size="45" font-family="Verdana" x="150" y="86" transform="rotate(30 150,86)">SVG</text>
        </svg>
<pre>
&lt;svg height="150" width="400">
    &lt;defs>
        &lt;linearGradient <span style="color:blue;">id="grad1"</span> x1="0%" y1="0%" x2="100%" y2="0%">
        &lt;stop offset="0%" style="stop-color:rgb(255,255,0);stop-opacity:1" />
        &lt;stop offset="100%" style="stop-color:rgb(255,0,0);stop-opacity:1" />
        &lt;/linearGradient>
    &lt;/defs>
    &lt;ellipse cx="200" cy="70" rx="85" ry="55" <span style="color: blue;">fill="url(#grad1)"</span> />
    &lt;text fill="#ffffff" font-size="45" font-family="Verdana" x="150" y="86">SVG&lt;/text>
&lt;/svg>
</pre> <br>


        <svg height="150" width="500">
            <defs>
            <radialGradient id="grad2" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
                <stop offset="0%" style="stop-color:rgb(255,255,255); stop-opacity:0" />
                <stop offset="100%" style="stop-color:rgb(0,0,255);stop-opacity:1" />
            </radialGradient>
            </defs>
            <ellipse cx="200" cy="70" rx="85" ry="55" fill="url(#grad2)" />
        </svg>
<pre>
&lt;svg height="150" width="500">
    &lt;defs>
        &lt;radialGradient <span style="color:blue;">id="grad2"</span> cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
        &lt;stop offset="0%" style="stop-color:rgb(255,255,255); stop-opacity:0" />
        &lt;stop offset="100%" style="stop-color:rgb(0,0,255);stop-opacity:1" />
        &lt;/radialGradient>
    &lt;/defs>
    &lt;ellipse cx="200" cy="70" rx="85" ry="55" <span style="color: blue;">fill="url(#grad2)"</span> />
&lt;/svg>
</pre> <br>


        <svg height="400" width="450">
            <path id="lineAB" d="M 100 350 l 150 -300" stroke="red" stroke-width="3" fill="none" />
            <path id="lineBC" d="M 250 50 l 150 300" stroke="red" stroke-width="3" fill="none" />
            <path d="M 175 200 l 150 0" stroke="yellow" stroke-width="3" fill="none" />
            <path d="M 100 350 q 150 -300 300 0" stroke="blue" stroke-width="5" fill="none" />
            
            <g font-size="30" font-family="sans-serif" fill="black" stroke="none" text-anchor="middle">
            <text x="100" y="350" dx="-30">A</text>
            <text x="250" y="50" dy="-10">B</text>
            <text x="400" y="350" dx="30">C</text>
            </g>  
        </svg>
<pre>
&lt;svg height="400" width="450">
    &lt;path id="lineAB" d="M 100 350 l 150 -300" stroke="red" stroke-width="3" fill="none" />
    &lt;path id="lineBC" d="M 250 50 l 150 300" stroke="red" stroke-width="3" fill="none" />
    &lt;path d="M 175 200 l 150 0" stroke="yellow" stroke-width="3" fill="none" />
    &lt;path d="M 100 350 q 150 -300 300 0" stroke="blue" stroke-width="5" fill="none" />
    
    &lt;g font-size="30" font-family="sans-serif" fill="black" stroke="none" text-anchor="middle">
    &lt;text x="100" y="350" dx="-30">A&lt;/text>
    &lt;text x="250" y="50" dy="-10">B&lt;/text>
    &lt;text x="400" y="350" dx="30">C&lt;/text>
    &lt;/g>  
&lt;/svg>
</pre> <br>
        <div class="content_box">
            <p>
                M = moveto <br>
                L = lineto <br>
                H = horizontal lineto <br>
                V = vertical lineto <br>
                C = curveto <br>
                S = smooth curveto <br>
                Q = quadratic Bézier curve <br>
                T = smooth quadratic Bézier curveto <br>
                A = elliptical Arc <br>
                Z = closepath
            </p>
        </div> <br>


        <svg width="45" height="45">
            <g transform="translate(22.5,22.5)">
                <circle r="20" fill="rgb(255, 255, 255)" stroke="rgb(206, 229, 253)" stroke-width="5"></circle>
                <circle r="20" fill="none" transform="rotate(-90)" stroke="rgb(50, 161, 255)" stroke-width="5" stroke-linecap="round" stroke-dasharray="62.83184" stroke-dashoffset=""></circle>        
            </g>    
        </svg>
<pre>
&lt;svg width="45" height="45">
    &lt;g transform="translate(22.5,22.5)">
        &lt;circle r="20" fill="rgb(255, 255, 255)" stroke="rgb(206, 229, 253)" stroke-width="5">&lt;/circle>
        &lt;circle r="20" fill="none" transform="rotate(-90)" stroke="rgb(50, 161, 255)" stroke-width="5" stroke-linecap="round" stroke-dasharray="62.83184" stroke-dashoffset="">&lt;/circle>
        //stroke-dasharray="10 30" : 길이10-공백30이 연속된 대시라인 스트로크를 그림
        //stroke-dashoffset : 시작점을 앞당김 (dasharray에서 공백을 지정하였다면 라인의 길이가 줄어듦)
    &lt;/g>    
&lt;/svg>    
</pre>

    </div>


<!--body 끝--> </body>


</html>
